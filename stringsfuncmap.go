// Functions from Go's strings package usable as template actions
package goutils

import "strings"

// StringsFuncs is a template.FuncMap with functions that can be used as template actions.
var StringsFuncs = map[string]interface{}{
	"Contains":    func(s, substr string) bool { return strings.Contains(s, substr) },
	"ContainsAny": func(s, chars string) bool { return strings.ContainsAny(s, chars) },
	//"ContainsRune": func(s string, r rune) bool { return strings.ContainsRune(s, r) },
	"Count":     func(s, sep string) int { return strings.Count(s, sep) },
	"EqualFold": func(s, t string) bool { return strings.EqualFold(s, t) },
	"Fields":    func(s string) []string { return strings.Fields(s) },
	//"FieldsFunc": func(s string, f func(rune) bool) []string { return strings.FieldsFunc(s, f) },
	"HasPrefix": func(s, prefix string) bool { return strings.HasPrefix(s, prefix) },
	"HasSuffix": func(s, suffix string) bool { return strings.HasSuffix(s, suffix) },
	"Index":     func(s, sep string) int { return strings.Index(s, sep) },
	"IndexAny":  func(s, chars string) int { return strings.IndexAny(s, chars) },
	//"IndexByte": func(s string, c byte) int { return strings.IndexByte(s, c) },
	//"IndexFunc": func(s string, f func(rune) bool) int { return strings.IndexFunc(s, f) },
	//"IndexRune": func(s string, r rune) int { return strings.IndexRune(s, r) 	},
	"Join":         func(a []string, sep string) string { return strings.Join(a, sep) },
	"LastIndex":    func(s, sep string) int { return strings.LastIndex(s, sep) },
	"LastIndexAny": func(s, chars string) int { return strings.LastIndexAny(s, chars) },
	//"LastIndexFunc": func(s string, f func(rune) bool) int { return strings.LastIndexFunc(s, f) },
	//"Map": func(mapping func(rune) rune, s string) string { return strings.Map(mapping, s) },
	//"Repeat": func(s string, count int) string { return strings.Repeat(s, count) },
	"Replace":     func(s, old, new string, n int) string { return strings.Replace(s, old, new, n) },
	"Split":       func(s, sep string) []string { return strings.Split(s, sep) },
	"SplitAfter":  func(s, sep string) []string { return strings.SplitAfter(s, sep) },
	"SplitAfterN": func(s, sep string, n int) []string { return strings.SplitAfterN(s, sep, n) },
	"SplitN":      func(s, sep string, n int) []string { return strings.SplitN(s, sep, n) },
	"Title":       func(s string) string { return strings.Title(s) },
	"ToLower":     func(s string) string { return strings.ToLower(s) },
	//"ToLowerSpecial": func(_case unicode.SpecialCase, s string) string { return strings.ToLowerSpecial(_case, s) },
	"ToTitle": func(s string) string { return strings.ToTitle(s) },
	//"ToTitleSpecial": func(_case unicode.SpecialCase, s string) string { return strings.ToTitleSpecial(_case, s) },
	"ToUpper": func(s string) string { return strings.ToUpper(s) },
	//"ToUpperSpecial": func(_case unicode.SpecialCase, s string) string { return strings.ToUpperSpecial(_case, s) },
	"Trim": func(s string, cutset string) string { return strings.Trim(s, cutset) },
	//"TrimFunc": func(s string, f func(rune) bool) string { return strings.TrimFunc(s, f) },
	"TrimLeft": func(s string, cutset string) string { return strings.TrimLeft(s, cutset) },
	//"TrimLeftFunc": func(s string, f func(rune) bool) string { return strings.TrimLeftFunc(s, f) },
	"TrimPrefix": func(s, prefix string) string { return strings.TrimPrefix(s, prefix) },
	"TrimRight":  func(s string, cutset string) string { return strings.TrimRight(s, cutset) },
	//"TrimRightFunc": func(s string, f func(rune) bool) string { return strings.TrimRightFunc(s, f) },
	"TrimSpace":  func(s string) string { return strings.TrimSpace(s) },
	"TrimSuffix": func(s, suffix string) string { return strings.TrimSuffix(s, suffix) },
}
